// /app/api/line/route.ts
import { NextRequest, NextResponse } from "next/server";
import crypto from "crypto";
import { Client, WebhookEvent, FollowEvent } from "@line/bot-sdk";
import dotenv from "dotenv";
import { connectToDatabase } from "@/lib/mongodb";
import User from "@/models/User";

dotenv.config();

// üîπ ‡∏™‡∏£‡πâ‡∏≤‡∏á LINE client
const client = new Client({
  channelAccessToken: process.env.LINE_CHANNEL_ACCESS_TOKEN!,
  channelSecret: process.env.LINE_CHANNEL_SECRET!,
});

// üîπ ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á Gemini Response
interface GeminiPart { text: string }
interface GeminiContent { role: string; parts: GeminiPart[] }
interface GeminiCandidate { content: GeminiContent }
interface GeminiResponse { candidates?: GeminiCandidate[] }

// üîπ ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° fallback
function getFriendlyFallback(): string {
  const options = [
    "‡∏≠‡πã‡∏≠ ‡∏ú‡∏°‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡πÅ‡∏ô‡πà‡πÉ‡∏à ‡πÅ‡∏ï‡πà‡∏•‡∏≠‡∏á‡πÄ‡∏•‡πà‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏´‡∏ô‡πà‡∏≠‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö",
    "‡∏ô‡πà‡∏≤‡∏™‡∏ô‡πÉ‡∏à‡∏Ñ‡∏£‡∏±‡∏ö! ‡∏Ñ‡∏∏‡∏ì‡∏≠‡∏¢‡∏≤‡∏Å‡πÉ‡∏´‡πâ‡∏ú‡∏°‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏°‡∏ô‡∏π‡∏≠‡∏µ‡∏Å‡πÑ‡∏´‡∏°?",
    "‡∏Æ‡πà‡∏≤ ‡πÜ ‡∏ú‡∏°‡∏≠‡∏≤‡∏à‡∏ï‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å ‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏≤‡∏°‡∏≤‡∏Ñ‡∏∏‡∏¢‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤",
  ];
  return options[Math.floor(Math.random() * options.length)];
}

// üîπ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å (Webhook)
export async function POST(req: NextRequest) {
  try {
    const body = await req.text();
    const signature = req.headers.get("x-line-signature");
    if (!signature) return new NextResponse("Missing signature", { status: 401 });

    const hash = crypto.createHmac("sha256", process.env.LINE_CHANNEL_SECRET!)
      .update(body).digest("base64");
    if (signature !== hash) return new NextResponse("Invalid signature", { status: 401 });

    await connectToDatabase();
    const parsedBody = JSON.parse(body) as { events: WebhookEvent[] };

    for (const event of parsedBody.events) {

      // üÜï ‡∏Å‡∏£‡∏ì‡∏µ follow (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô)
      if (event.type === "follow") {
        const followEvent = event as FollowEvent;
        const userId = followEvent.source.userId!;
        let userDoc = await User.findOne({ lineId: userId });
        if (!userDoc) {
          userDoc = await User.create({
            lineId: userId,
            awaitingName: true,
            conversation: [],
          });
        }
        await client.replyMessage(followEvent.replyToken, {
          type: "text",
          text:
            "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡∏£‡∏±‡∏ö üòä ‡∏ú‡∏°‡∏Ñ‡∏∑‡∏≠ Mr. Rice ‡∏ú‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏¢‡∏î‡πâ‡∏≤‡∏ô‡πÇ‡∏†‡∏ä‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏£‡∏±‡∏ö\n" +
            "‡∏Å‡πà‡∏≠‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡∏Ç‡∏≠‡∏ó‡∏£‡∏≤‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏•‡πà‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏´‡∏ô‡πà‡∏≠‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö üçö",
        });
        continue;
      }

      // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
      if (event.type !== "message" || event.message.type !== "text") continue;

      const messageEvent = event as import("@line/bot-sdk").MessageEvent;
      const replyToken = messageEvent.replyToken;
      const userId = messageEvent.source.userId!;

      // üîπ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
      let userMessage = (messageEvent.message as { text: string }).text.trim();

      // üîπ ‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô MongoDB
      let userDoc = await User.findOne({ lineId: userId });

      if (!userDoc) {
        // ‡∏´‡∏≤‡∏Å‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏û‡∏¥‡∏°‡∏û‡πå‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô follow
        const existingUser = await User.findOne({ name: userMessage });
        if (existingUser) {
          existingUser.lineId = userId;
          await existingUser.save();
          await client.replyMessage(replyToken, {
            type: "text",
            text: `‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡∏£‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì ${existingUser.name}! ‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏Ñ‡∏£‡∏±‡∏ö üòä`,
          });
          continue;
        } else {
          userDoc = await User.create({
            name: userMessage || "‡πÑ‡∏°‡πà‡∏°‡∏µ",
            lineId: userId,
            awaitingName: true,
            conversation: [],
          });
          await client.replyMessage(replyToken, {
            type: "text",
            text: `‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å‡∏Ñ‡∏£‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì ${userMessage || "‡πÑ‡∏°‡πà‡∏°‡∏µ"}! ‡∏Ñ‡∏∏‡∏ì‡∏ä‡πà‡∏ß‡∏¢‡∏ö‡∏≠‡∏Å‡∏´‡∏ô‡πà‡∏≠‡∏¢‡∏ß‡πà‡∏≤‡πÑ‡∏•‡∏ü‡πå‡∏™‡πÑ‡∏ï‡∏•‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ö‡∏ö‡πÑ‡∏´‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö?`,
          });
          continue;
        }
      }

      // üîπ ‡∏ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏£‡∏≠‡∏ä‡∏∑‡πà‡∏≠
      if (userDoc.awaitingName) {
        const name = userMessage || "‡πÑ‡∏°‡πà‡∏°‡∏µ";
        await User.updateOne({ lineId: userId }, { name, awaitingName: false });
        await client.replyMessage(replyToken, {
          type: "text",
          text: `‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å‡∏Ñ‡∏£‡∏±‡∏ö ‡∏Ñ‡∏∏‡∏ì ${name} üòä ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ñ‡∏≤‡∏°‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÄ‡∏°‡∏ô‡∏π‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö`,
        });
        continue;
      }

      // üîπ ‡∏ñ‡πâ‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ä‡∏∑‡πà‡∏≠‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á
      if (userMessage === userDoc.name) {
        await client.replyMessage(replyToken, {
          type: "text",
          text: `‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏Ñ‡∏£‡∏±‡∏ö ‡∏Ñ‡∏∏‡∏ì ${userDoc.name} üòä`,
        });
        continue;
      }

      // üîπ ‡πÇ‡∏ï‡πâ‡∏ï‡∏≠‡∏ö‡∏ú‡πà‡∏≤‡∏ô Gemini AI
      const recentConversation = (userDoc.conversation || []).slice(-10);
      const geminiResponse = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${process.env.NEXT_PUBLIC_GEMINI_API_KEY}`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            contents: [
              ...recentConversation.map((_msg: { role: string; text: string }) => ({
                role: _msg.role,
                parts: [{ text: _msg.text }],
              })),
              {
                role: "user",
                parts: [{ text: `
‡∏Ñ‡∏∏‡∏ì‡∏ä‡∏∑‡πà‡∏≠ Mr. Rice ‡πÄ‡∏õ‡πá‡∏ô‡∏ô‡∏±‡∏Å‡πÇ‡∏†‡∏ä‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏ú‡∏π‡πâ‡∏ä‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡πÉ‡∏à‡∏î‡∏µ ‡∏≠‡πà‡∏≠‡∏ô‡πÇ‡∏¢‡∏ô ‡∏™‡∏∏‡∏†‡∏≤‡∏û
‡πÄ‡∏ä‡∏µ‡πà‡∏¢‡∏ß‡∏ä‡∏≤‡∏ç‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡πâ‡∏≤‡∏ß ‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≤‡∏ß‡∏Å‡∏•‡πâ‡∏≠‡∏á
-‡∏ï‡∏≠‡∏ö‡∏™‡∏±‡πâ‡∏ô ‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 4 ‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î
-‡∏´‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏û‡∏¥‡∏°‡∏û‡πå‡πÉ‡∏´‡πâ ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏°‡∏ô‡∏π ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ (goal, condition, lifestyle) 
‡πÅ‡∏•‡∏∞‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏ß‡πà‡∏≤‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏≠‡∏∞‡πÑ‡∏£
-‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡πÅ‡∏ô‡πà‡πÉ‡∏à‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏∏‡∏†‡∏≤‡∏û ‡πÑ‡∏°‡πà‡∏û‡∏π‡∏î‡∏ß‡πà‡∏≤ "‡πÑ‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à"
- ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ 
‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: "${userMessage}"
                ` }],
              },
            ],
          }),
        }
      );

      const data: GeminiResponse = await geminiResponse.json();
      const replyText = data.candidates?.[0]?.content.parts?.[0]?.text || getFriendlyFallback();

      // üîπ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ö‡∏ó‡∏™‡∏ô‡∏ó‡∏ô‡∏≤
      await User.updateOne(
        { lineId: userId },
        {
          $push: {
            conversation: {
              $each: [
                { role: "user", text: userMessage },
                { role: "assistant", text: replyText },
              ],
              $slice: -10,
            },
          },
        }
      );

      // üîπ ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏•‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
      await client.replyMessage(replyToken, { type: "text", text: replyText });
    }

    return NextResponse.json({ message: "OK" });
  } catch (error) {
    console.error("‚ùå Error:", error);
    return NextResponse.json({ error: String(error) }, { status: 500 });
  }
}
